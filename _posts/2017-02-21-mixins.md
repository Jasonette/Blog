---
layout: post
title: Mix~in!
image: assets/mixins.jpg
---

Have you met Frank, the ice cream truck guy? He takes a cone, adds a scoop of ice cream, maybe one more, adds some syrup, adds some sprinkles, and there you go, you have an ice cream cone!

<img src='/assets/mixins.png'>

He probably didn't make the sprinkles himself, he probably didn't make the syrup, and he probably didn't make the cones, but **he magically puts them all together and makes a really good ice cream cone in only ten seconds**, and that's why we love him!

Same with Jasonette:

You shouldn't have to start from scratch. **You should only have to put together what someone else made, and still perform magic!**

<br>

# What is a Mix-in?

Mix-ins let you compose multiple JSON objects into one. Since everything on Jasonette is written in JSON, this means you can mix in anything from actions to styles to templates!


You can implement a mixin simply by adding a key named `"@"` and setting a URL as its value. Every time a Jasonette view loads, it:

1. Looks at all occurrences of `"@": URL` pairs.
2. Fetches all the URL content, in parallel.
3. Lastly, replaces the mixin expressions with returned objects.

<br>


# Usage

## 1. Basic

Let's say `https://jasonbase.com/things/h3f.json` returns a JSON object that looks like this:

```json
{
	"type": "label",
	"text": "Hello",
	"style": {
		"font": "HelveticaNeue",
		"color": "#ff0000"
	}
}
```

Here's a mix-in expression:

```json
{
	"item": {
		"@": "https://jasonbase.com/things/h3f.json"
	}
}
```

When the mix-in is resolved, it becomes:

```json
{
	"item": {
		"type": "label",
		"text": "Hello",
		"style": {
			"font": "HelveticaNeue",
			"color": "#ff0000"
		}
	}
}
```

Think of it as "pull the JSON object from `https://jasonbase.com/things/h3f.json` and attach it right here under `item`".

---

## 2. Array
In the preivious section we saw how a `"@": URL` pair resolves to a JSON object.

But you can also mix-in an array of URLs (example: `"@": [URL, URL,.., URL]`).

Here's an example where we mix-in the same JSON object 3 times:

```json
{
	"items": {
		"@": [
			"https://jasonbase.com/things/h3f.json",
			"https://jasonbase.com/things/h3f.json",
			"https://jasonbase.com/things/h3f.json"
		]
	}
}
```

When resolved, this becomes:

```json
{
	"items": [
		{
			"type": "label",
			"text": "Hello",
			"style": {
				"font": "HelveticaNeue",
				"color": "#ff0000"
			}
		},
		{
			"type": "label",
			"text": "Hello",
			"style": {
				"font": "HelveticaNeue",
				"color": "#ff0000"
			}
		},
		{
			"type": "label",
			"text": "Hello",
			"style": {
				"font": "HelveticaNeue",
				"color": "#ff0000"
			}
		}
	]
}
```

<br>

# How is Mix-in different from $require?

## 1. Mix-ins modify the JSON markup itself.

When I say JSON markup, I mean the main JSON that loads from the url you added, with a format that looks like this:

```json
{
  "$jason": {
    "head": { },
    "body": { }
  }
}
```

[$require]() is an action, and actions can't exist until the main JSON has been interpreted and turned into a view. $require doesn't have the power to modify the very JSON markup tree itself.

However, **mix-ins are all about constructing the JSON markup itself from multiple JSON objects.**

Which means something like the following is possible with mix-ins:

```json
{
  "$jason": {
    "head": {
      "@": "https://jasonbase.com/things/333.json"
    },
    "body": {
      "@": "https://jasonbase.com/things/enf.json"
    }
  }
}
```

## 2. Mix-ins get resolved before everything else

You already know how Jasonette works:

1. Fetches a JSON markup from a URL
2. Interprets the fetched JSON to construct a view
3. Bootstraps an `actions` controller which takes care of running actions

Like mentioned above, since [$require]() is an [action](), its life starts after step 3.

On the other hand, mix-ins get resolved on **step 1**, even before any interpretation is made. Here's what it now looks like with the new mix-in engine:

1. Fetches a JSON markup from a URL
2. **The mix-in engine looks for any `"@"` references**
3. **If any exist, the mix-in engine fetches all the referenced JSON objects and mixes them in to construct the final JSON markup.**
4. Interprets the fetched JSON to construct a view
5. Bootstraps an `actions` controller which takes care of running actions

<br>

<br>

# Features

Due to the recursive and composable nature of JSON, Mix-ins are infinitely flexible.

You can do all kinds of things with mix-ins. Let's take a look:

<br>

## Multiple Mix-ins
There is NO limit to the number of times you can mix-in a remote JSON into your main JSON. They all get fetched and mixed into the main JSON object, in parallel.

```json
{
	"model": {
		"@": "https://jasonbase.com/things/3nf.json"
	},
	"view": {
		"@": "https://jasonbase.com/things/13f.json"
	},
	"controller": {
		"@": "https://jasonbase.com/things/ina.json"
	}
}
```

<br>

## Mix-ins Everywhere

You can use mix-ins **anywhere in the JSON tree**, as many times as you want.

Just remember that the mix-in resolution happens before everything else, and each mixed in JSON object gets merged in a very literal manner.

```json
{
	"$jason": {
		"head": {
			"styles": {
				"@": "https://jasonbase.com/things/3nf.json"
			},
			"templates": {
				"@": "https://jasonbase.com/things/a33.json"
			},
			"actions": {
				"oauth": {
					"@": "https://jasonbase.com/things/4nf.json"
				},
				"$load": {
					"trigger": "oauth",
					"success": {
						"type": "$render"
					}
				}
			}
		}
	}
}
```

<br>

## Inheritance

Going extreme, you can even mix-in an entire JSON object to inherit from it.

```json
{
	"@": "https://jasonbase.com/things/3nf.json"
}
```

You may be asking "Why would I do that?". Which brings us to....

<br>

## Overriding

In many cases you probably want to:

1. Mix-in some generic JSON module
2. Then override some of the JSON attributes with your own to customize.

Above example of mixing in an entire JSON is such a case. It becomes really powerful when you can mix in a JSON object AND override on top of that--it effectively becomes inheritance.

Let's say `https://jasonbase.com/things/3nf.json` contained the following JSON:
	
```json
{
	"lastname": "Simpson",
	"address": "742 Evergreen Terrace",
	"city": "Springfield"
}
```

Here's a mix-in expression that references above JSON object:

```json
[{
	"firstname": "Bart",
	"@": "https://jasonbase.com/things/3nf.json"
}, {
	"firstname": "Homer",
	"@": "https://jasonbase.com/things/3nf.json"
}, {
	"firstname": "Lisa",
	"@": "https://jasonbase.com/things/3nf.json"
}, {
	"firstname": "Maggie",
	"@": "https://jasonbase.com/things/3nf.json"
}, {
	"firstname": "Marge",
	"@": "https://jasonbase.com/things/3nf.json"
}]
```

When resolved, it becomes:

```json
[{
	"firstname": "Bart",
	"lastname": "Simpson",
	"address": "742 Evergreen Terrace",
	"city": "Springfield"
}, {
	"firstname": "Homer",
	"lastname": "Simpson",
	"address": "742 Evergreen Terrace",
	"city": "Springfield"
}, {
	"firstname": "Lisa",
	"lastname": "Simpson",
	"address": "742 Evergreen Terrace",
	"city": "Springfield"
}, {
	"firstname": "Maggie",
	"lastname": "Simpson",
	"address": "742 Evergreen Terrace",
	"city": "Springfield"
}, {
	"firstname": "Marge",
	"lastname": "Simpson",
	"address": "742 Evergreen Terrace",
	"city": "Springfield"
}]
```

<br>

## Real-life Example

Consider a Jasonette app that looks like this:

```
{
  "$jason": {
    "head": {
      "data": {
        "items": [{
          "image": "",
          "title": "",
          "subtitle": ""
        }, {
          "image": "",
          "title": "",
          "subtitle": ""
        }, {
          "image": "",
          "title": "",
          "subtitle": ""
        }]
      },
      "templates": {
        "body": {
          "sections": [{
            "items": {
              "{{#each items}}": {
                "type": "horizontal",
                "style": {
                  "spacing": "10"
                },
                "components": [{
                  "type": "image",
                  "url": "{{image}}",
                  "style": {
                    "width": "50",
                    "height": "50"
                  }
                }, {
                  "type": "vertical",
                  "components": [{
                    "type": "label",
                    "text": "{{title}}"
                  }, {
                    "type": "label",
                    "text": "{{subtitle}}"
                  }]
                }]
              }
            }
          }]
        }
      }
    }
  }
}
```

Here we have a **data** object and a **templates.body** object which will render the data.

Let's turn these into mixins.

### Step 1. Data
We will extract the data part out as its own JSON:

**https://jasonbase.com/things/n4f.json**

```
{
  "items": [{
    "image": "",
    "title": "",
    "subtitle": ""
  }, {
    "image": "",
    "title": "",
    "subtitle": ""
  }, {
    "image": "",
    "title": "",
    "subtitle": ""
  }]
}
```

### Step 2. Template
Next stop, we extract out the template, so we can reuse the template everywhere:

**https://jasonbase.com/things/3fs.json**

```
{
  "body": {
    "sections": [{
      "items": {
        "{{#each items}}": {
          "type": "horizontal",
          "style": {
            "spacing": "10"
          },
          "components": [{
            "type": "image",
            "url": "{{image}}",
            "style": {
              "width": "50",
              "height": "50"
            }
          }, {
            "type": "vertical",
            "components": [{
              "type": "label",
              "text": "{{title}}"
            }, {
              "type": "label",
              "text": "{{subtitle}}"
            }]
          }]
        }
      }
    }]
  }
}
```

### Step 3. Let's mix them in!
Now we will turn the original JSON and use mixins to express the same:

```
{
  "$jason": {
    "head": {
      "data": {
        "@": "https://jasonbase.com/things/n4f.json"
      },
      "templates": {
        "@": "https://jasonbase.com/things/3fs.json"
      }
    }
  }
}
```

This is exactly the same app as we started with. Try it--Download Jason and enter this link: https://jasonbase.com/things/3fs.json

There is no magic.

<br>

## Last Boss --- Self Mix-in 

<br>

Is your mind blown yet?

If you are still standing, here's the final piece of the puzzle which takes this to a whole new level: **Self-mixins**

<img src='/assets/snake.png'>

Self mixins let you mix-in a JSON object to itself.


Step 1. Let's 

Let's take a look at this:

```
{
  "card": {
    "type": "horizontal",
    "style": {
      "spacing": "10"
    },
    "components": [{
      "type": "image",
      "url": "{{image}}",
      "style": {
        "width": "50",
        "height": "50"
      }
    }, {
      "type": "vertical",
      "components": [{
        "type": "label",
        "text": "{{title}}"
      }, {
        "type": "label",
        "text": "{{subtitle}}"
      }]
    }]
  }
}
```


**This is one of the reasons why a JSON-powered programming language is so powerful, and it's why I choose JSON.**

JSON is recursive, you can compose it any way you want.




# Timing

# Let's turn Instagram into a toy

Throughout the rest of this article I will show you how this can be done. Let's take the Instagram example we already have, and turn it into a reusable toy.

# Step 1. Data
If you look at the JSON file, `$jason.head.data` contains the following:

```json
{
	"posts": [{
		"type": "stories",
		"items": [{
			"avatar": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/barton_avatar.png",
			"name": "Barton",
			"location": "Somewhere",
			"content": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/barton.jpg"
		}, {
			"avatar": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/audrey_avatar.png",
			"name": "Audrey",
			"location": "Somewhere",
			"content": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/audrey.jpg"
		}, {
			"avatar": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/boss_avatar.png",
			"name": "Audrey",
			"location": "Somewhere",
			"content": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/boss.jpg"
		}, {
			"avatar": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/chet_avatar.png",
			"name": "Chet!",
			"location": "Somewhere",
			"content": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/chet.jpg"
		}, {
			"avatar": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/girl_avatar.png",
			"name": "Girl",
			"location": "Somewhere",
			"content": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/girl.jpg"
		}]
	}, {
		"avatar": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/barton_avatar.png",
		"name": "Barton",
		"location": "Somewhere",
		"content": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/barton.jpg"
	}, {
		"avatar": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/audrey_avatar.png",
		"name": "Audrey",
		"location": "Somewhere",
		"content": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/audrey.jpg"
	}, {
		"avatar": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/boss_avatar.png",
		"name": "Audrey",
		"location": "Somewhere",
		"content": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/boss.jpg"
	}, {
		"avatar": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/chet_avatar.png",
		"name": "Chet!",
		"location": "Somewhere",
		"content": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/chet.jpg"
	}, {
		"avatar": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/girl_avatar.png",
		"name": "Girl",
		"location": "Somewhere",
		"content": "https://raw.githubusercontent.com/Jasonette/Instagram-UI-example/master/images/girl.jpg"
	}]
}
```

Let's take the Instagram example we already have and 

One JSON file may be specifically for displaying views.

# Write, share, and reuse.

Let's take a btoa for example. We implemented a string-to-hash algorithm in javascript

{% raw %}
```
{
  "fetch": {
    "type": "$network.request",
    "options": {
      "url": "https://.....",
      "method": "POST",
      "data": {
        "guid": "{{var str=$cache.guid; var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; for ( var block, charCode, idx = 0, map = chars, output = ''; str.charAt(idx | 0) || (map = '=', idx % 1); output += map.charAt(63 & block >> 8 - idx % 1 * 8)) { charCode = str.charCodeAt(idx += 3/4); if (charCode > 0xFF) { throw new InvalidCharacterError('btoa failed'); } block = block << 8 | charCode; } return output;}}"
      }
    },
    "success": {
      "type": "$render"
    }
  }
}
```
{% endraw %}

We had extracted this out as its own standalone action too.

{% raw %}
```
{
  "btoa": {
    "type": "$return.success",
    "options": {
      "hashed": "{{var str=$jason.guid; var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; for ( var block, charCode, idx = 0, map = chars, output = ''; str.charAt(idx | 0) || (map = '=', idx % 1); output += map.charAt(63 & block >> 8 - idx % 1 * 8)) { charCode = str.charCodeAt(idx += 3/4); if (charCode > 0xFF) { throw new InvalidCharacterError('btoa failed'); } block = block << 8 | charCode; } return output;}}"
    }
  }
}
```
{% endraw %}

So, now that we have mixins, how do we reuse this?


{% raw %}
```
{
  "btoa": {
    "type": "$return.success",
    "options": {
      "hashed": "{{var str=$jason.guid; var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='; for ( var block, charCode, idx = 0, map = chars, output = ''; str.charAt(idx | 0) || (map = '=', idx % 1); output += map.charAt(63 & block >> 8 - idx % 1 * 8)) { charCode = str.charCodeAt(idx += 3/4); if (charCode > 0xFF) { throw new InvalidCharacterError('btoa failed'); } block = block << 8 | charCode; } return output;}}"
    }
  },
  "fetch": {
    "trigger": "btoa",
    "options": {
      "guid": "Hello World"
    },
    "success": {
      "type": "$network.request",
      "options": {
        "url": "https://.....",
        "method": "POST",
        "data": {
          "guid": "{{$jason.hashed}}"
        }
      },
      "success": {
        "type": "$render"
      }
    }
  }
}
```
{% endraw %}


# How it's related to $require
In the last post I talked about [$require](). $require is really great for importing remote JSON files on the fly. However it's not 



# Don't start from scratch!

![Takethis](/assets/takethis.png)

Jasonette has made it extremely easy to make apps. All you need to do is write a single JSON markup.

**But guess what? I don't want you to write JSON anymore.**

Instead, I want people to easily make apps by mixing multiple pre-made JSON files, in any way you want, just like Frank makes his ice cream cones.

<br>

